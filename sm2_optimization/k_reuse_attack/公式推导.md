# SM2 签名算法中重用随机数 k 导致私钥泄露的推导过程

本文档分析了两种因 SM2 签名过程中随机数 `k` 使用不当而导致私钥泄露的攻击场景。

## 攻击场景一：同一用户对不同消息重用 k

### 1. 场景描述

一个用户使用自己的私钥 `d` 对两条不同的消息 `M1` 和 `M2` 进行签名，但在两次签名过程中“错误地”使用了完全相同的随机数 `k`。

### 2. SM2 签名算法回顾

SM2 签名算法的核心步骤如下：

1.  **计算消息摘要**: `e = H(Z || M)`
2.  **生成随机数**: 选择一个随机数 `k`，`1 <= k < n`
3.  **计算椭圆曲线点**: `(x1, y1) = k * G`
4.  **计算签名 r**: `r = (e + x1) mod n`
5.  **计算签名 s**: `s = (inv(1 + d) * (k - r * d)) mod n`

最终的签名是 `(r, s)`。

### 3. 私钥推导过程

假设攻击者获得了该用户对 `M1` 和 `M2` 的签名，分别为 `(r1, s1)` 和 `(r2, s2)`。

-   **签名 1**:
    -   `e1 = H(Z || M1)`
    -   `r1 = (e1 + x1) mod n`
    -   `s1 = (inv(1 + d) * (k - r1 * d)) mod n`  **(公式 1)**

-   **签名 2**:
    -   `e2 = H(Z || M2)`
    -   由于 `k` 被重用，`x1` 也是相同的。
    -   `r2 = (e2 + x1) mod n`
    -   `s2 = (inv(1 + d) * (k - r2 * d)) mod n`  **(公式 2)**

从公式 1 和 2 中，我们可以变换公式以隔离 `k`：

从公式 1 得： `k = s1 + (r1 + s1) * d  (mod n)`  **(公式 3)**

从公式 2 得： `k = s2 + (r2 + s2) * d  (mod n)`  **(公式 4)**

令公式 3 等于公式 4：
`s1 + (r1 + s1) * d = s2 + (r2 + s2) * d  (mod n)`

求解 `d`：
`(r1 - r2 + s1 - s2) * d = s2 - s1  (mod n)`

最终得到私钥 `d` 的计算公式：
**`d = (s2 - s1) * inv(r1 - r2 + s1 - s2)  (mod n)`**

由于公式中所有变量（`r1, s1, r2, s2, n`）都是公开的，攻击者可以轻易计算出用户的私钥 `d`。

---

## 攻击场景二：不同用户“碰撞”并重用 k

### 1. 场景描述

两个不同的用户，Alice 和 Bob，拥有各自的私钥 `da` 和 `db`。他们在对各自不同的消息进行签名时，完全是偶然地，使用了同一个随机数 `k`。

### 2. 漏洞原理

这个漏洞的核心在于，任何一方都可以利用自己的私钥和签名，从公开信息中反解出那个被共享的随机数 `k`。一旦 `k` 被恢复，就可以用它来破解另一方的私钥。

### 3. 私钥破解过程（以 Alice 破解 Bob 的私钥为例）

假设 Alice 获得了 Bob 对某条消息的签名 `(rb, sb)`，并且她知道这次签名与自己某次签名 `(ra, sa)` 使用了相同的 `k`。

1.  **Alice 恢复随机数 k**:
    Alice 知道自己的私钥 `da` 和自己的签名 `(ra, sa)`。她可以从自己的签名公式 `sa = (inv(1 + da) * (k - ra * da)) mod n` 进行变换来求解 `k`：
    `sa * (1 + da) = k - ra * da  (mod n)`
    `sa + sa * da = k - ra * da  (mod n)`
    `k = sa + sa * da + ra * da  (mod n)`
    **`k = sa + (ra + sa) * da  (mod n)`**  **(公式 5)**
    由于 `sa, ra, da` 对 Alice 都是已知的，她可以计算出 `k`。

2.  **Alice 使用 k 破解 Bob 的私钥 db**:
    现在 Alice 知道了 `k`，也知道 Bob 的签名 `(rb, sb)`。她可以利用 Bob 的签名公式来求解 `db`：
    `sb = (inv(1 + db) * (k - rb * db)) mod n`
    `sb * (1 + db) = k - rb * db  (mod n)`
    `sb + sb * db = k - rb * db  (mod n)`
    `db * (sb + rb) = k - sb  (mod n)`
    **`db = (k - sb) * inv(sb + rb)  (mod n)`**  **(公式 6)**

    公式 6 中的所有变量（`k, sb, rb, n`）对于 Alice 来说都已成为已知数，因此她可以计算出 Bob 的私钥 `db`。

### 4. 结论

这个攻击场景虽然看似巧合，但在大规模应用中，由于随机数生成器可能存在的缺陷（例如，不够随机、熵池不足、在虚拟化环境中启动时状态相同），导致不同用户生成相同 `k` 的概率并非为零。一旦发生，就会造成互相泄露私钥的严重后果。这也再次强调了密码安全中高质量随机数源的重要性。